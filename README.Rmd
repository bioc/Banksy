---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "man/figures/README-",
    out.width = "100%"
)
```

## Overview

```{r, eval=T, include=F}
start.time <- Sys.time()
```

BANKSY is a method for clustering spatial transcriptomic data by augmenting the
transcriptomic profile of each cell with an average of the transcriptomes of its
spatial neighbors. By incorporating neighborhood information for clustering, 
BANKSY is able to

- improve cell-type assignment in noisy data
- distinguish subtly different cell-types stratified by microenvironment
- identify spatial zones sharing the same microenvironment

BANKSY is applicable to a wide array of spatial technologies (e.g. 10x Visium, 
Slide-seq, MERFISH) and scales well to large datasets. For more details, check 
out:

- the [preprint](https://www.biorxiv.org/content/10.1101/2022.04.14.488259v1),
- a [tweetorial](https://twitter.com/vipul1891/status/1515323372535644166?s=20&t=Bc6rz8VeWWptF67FejGYfQ) on BANKSY, 
- and a [Python version](https://github.com/prabhakarlab/Banksy_py) of this package. 

## Installation

The *Banksy* package can be installed via `remotes`:

```{r, eval=F}
remotes::install_github("prabhakarlab/Banksy")
```

## Quick start

Load *BANKSY*. We'll also load *SpatialExperiment* and *SummarizedExperiment* 
for containing and manipulating the data, *scuttle* for normalization 
and quality control, and *scater*, *ggplot2* and *cowplot* for visualisation.

```{r, eval=T, warning=F, message=F}
library(Banksy)

library(SummarizedExperiment)
library(SpatialExperiment)
library(scuttle)

library(scater)
library(cowplot)
library(ggplot2)
```

Here, we'll run *BANKSY* on mouse hippocampus data. 

```{r, eval=T}
data(hippocampus)
gcm <- hippocampus$expression
locs <- as.matrix(hippocampus$locations)
```

Initialize a SpatialExperiment object and perform basic quality control and 
normalization. 

```{r, eval=T, message=F}
se <- SpatialExperiment(assay = list(counts = gcm), spatialCoords = locs)

# QC based on total counts
qcstats <- perCellQCMetrics(se)
thres <- quantile(qcstats$total, c(0.05, 0.98))
keep <- (qcstats$total > thres[1]) & (qcstats$total < thres[2])
se <- se[, keep]

# Normalization to mean library size
se <- computeLibraryFactors(se)
aname <- "normcounts"
assay(se, aname) <- normalizeCounts(se, log = FALSE)
```

Compute the neighborhood matrices for *BANKSY*. Setting `compute_agf=TRUE` 
computes both the weighted neighborhood mean ($\mathcal{M}$) and the azimuthal 
Gabor filter ($\mathcal{G}$). The number of spatial neighbors used to compute 
$\mathcal{M}$ and $\mathcal{G}$ are `k_geom[1]=15` and `k_geom[2]=30` 
respectively. We run *BANKSY* at `lambda=0` corresponding to non-spatial 
clustering, and `lambda=0.2` corresponding to  *BANKSY* for cell-typing.

```{r, eval=T}
lambda <- c(0, 0.2)
k_geom <- c(15, 30)

se <- Banksy::computeBanksy(se, assay_name = aname, compute_agf = TRUE, k_geom = k_geom)
```

Next, run PCA on the BANKSY matrix and perform clustering. Setting 
`use_agf=TRUE` uses both $\mathcal{M}$ and $\mathcal{G}$ to construct the 
BANKSY matrix.

```{r, eval=T}
set.seed(1000)
se <- Banksy::runBanksyPCA(se, use_agf = TRUE, lambda = lambda)
se <- Banksy::runBanksyUMAP(se, use_agf = TRUE, lambda = lambda)
se <- Banksy::clusterBanksy(se, use_agf = TRUE, lambda = lambda, resolution = 1.2)
```

Different clustering runs can be relabeled to minimise their differences with 
`connectClusters`:

```{r, eval=T}
se <- Banksy::connectClusters(se)
```

Visualise the clustering output for non-spatial clustering (`lambda=0`) and
BANKSY clustering (`lambda=0.2`).

```{r, eval=T, fig.height=5, fig.width=14}
cnames <- colnames(colData(se))
cnames <- cnames[grep("^clust", cnames)]
colData(se) <- cbind(colData(se), spatialCoords(se))

plot_nsp <- plotColData(se,
    x = "sdimx", y = "sdimy",
    point_size = 0.6, colour_by = cnames[1]
)
plot_bank <- plotColData(se,
    x = "sdimx", y = "sdimy",
    point_size = 0.6, colour_by = cnames[2]
)


plot_grid(plot_nsp + coord_equal(), plot_bank + coord_equal(), ncol = 2)
```

For clarity, we can visualise each of the clusters separately:

```{r, eval=T, fig.height=8, fig.width=18}
plot_grid(
    plot_nsp + facet_wrap(~colour_by),
    plot_bank + facet_wrap(~colour_by),
    ncol = 2
)
```

Visualize UMAPs of the non-spatial and BANKSY embedding:

```{r, eval=T, fig.height=5, fig.width=14}
rdnames <- reducedDimNames(se)

umap_nsp <- plotReducedDim(se,
    dimred = grep("UMAP.*lam0$", rdnames, value = TRUE),
    colour_by = cnames[1]
)
umap_bank <- plotReducedDim(se,
    dimred = grep("UMAP.*lam0.2$", rdnames, value = TRUE),
    colour_by = cnames[2]
)
plot_grid(
    umap_nsp,
    umap_bank,
    ncol = 2
)
```

<details>
    <summary>Runtime for analysis</summary>

```{r, eval=T, echo=FALSE}
Sys.time() - start.time
```

</details>

<details>
    <summary>Session information</summary>

```{r, sess}
sessionInfo()
```

</details>

