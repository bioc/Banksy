---
output: 
    github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# Banksy

<!-- badges: start -->
<!-- badges: end -->

Banksy is an R package that incorporates spatial information to cluster cells 
in a feature space (e.g. gene expression). Spatial information is incorporated 
by averaging the features of the k nearest neighbours to generate new 
'neighbour' features for a given cell. This is concatenated to the cell's own 
features to generate a combined feature matrix which is used for constructing a 
nearest neighbour network. Leiden clustering is used to obtain 
spatially-informed clusters.

# Installation

```{r, eval=F}
# Install from GitHub
remotes::install_github("jleechung/Banksy", dependencies = TRUE)
```

# Documentation

NOTE: These links will not work at the moment since the repo is still private.
Refer to the [vignettes](https://github.com/jleechung/Banksy/tree/main/vignettes) for the time being.

*Banksy* comes installed with [documentation](https://jleechung.github.io/Banksy/reference/index.html) 
of main functions and their usage, along with several vignettes which detail 
different use cases:

* [Working with Banksy objects](https://jleechung.github.io/Banksy/articles/banksy-object.html):
  Introduction to the *BanksyObject* class which serves as a container for *Banksy*.  
  
* [Finding optimal clustering parameters](https://jleechung.github.io/Banksy/articles/grid-search.html):
  Illustrates a grid search of parameters which best cluster cells.  

* [Analysing multiple datasets](https://jleechung.github.io/Banksy/articles/multiple-datasets.html):
  Illustrates analysis of multiple spatial transcriptomic datasets.

* [Integrating *Banksy* with other packages](https://jleechung.github.io/Banksy/articles/integrating-pkgs.html):
  Illustrates how users can integrate *Banksy* with packages like *Seurat* and *Giotto*.

# Basic Usage

## Input data

Inputs consist of an expression matrix and cell locations. Sample data is 
provided with the package:
```{r, eval = T}
library(Banksy)

expr <- readRDS(system.file('/extdata/expression.rds', package = 'Banksy'))
locs <- readRDS(system.file('/extdata/locations.rds', package = 'Banksy'))
```

The gene expression matrix for cells should be a `matrix`:
```{r, eval = T}
class(expr)
head(expr[,1:5])
```

while cell locations should be supplied as a `data.frame`:
```{r, eval = T}
class(locs)
head(locs)
```

We store the total number of detect genes and total counts as metadata:
```{r, eval = T}
metadata <- data.frame(num_genes = colSums(expr > 0),
                       total_count = colSums(expr))
```

Next, create a *BanksyObject* with the expression matrix and cell locations.

```{r, eval = T}
bank <- BanksyObject(own.expr = expr,
                     cell.locs = locs,
                     meta.data = metadata)
```

We can visualize the spatial layout of the cells, number of non-zero genes, 
and the expression of specific genes:

```{r, eval = T, fig.width=12, fig.height=10}
features <- c(NA, 'num_genes', 'Kcnh2', 'Slc38a1')
feature.types <- c(NA, rep('continuous', 3))
main <- features; main[1] <- ''
alpha <- c(0.2, rep(1, 3))
plotSpatialFeatures(bank, by = features, type = feature.types, main = main, 
                    nrow = 2, ncol = 2, pt.size = 1, pt.alpha = alpha, main.size = 10)
```

## Spatial clustering

We first normalize the expression matrix, compute the neighbour matrix, and scale 
the resulting gene-cell and neighbour feature-cell matrix.

```{r, eval = T}
bank <- NormalizeBanksy(bank, normFactor = 100)
bank <- ComputeBanksy(bank)
bank <- ScaleBanksy(bank)
```

At this point, the joint expression matrix (gene-cell matrix and neighbour 
feature-cell matrix) can be extracted with *getBanksyMatrix*, which returns
the joint matrix and cell locations. Here, `lambda` is a mixing parameter 
from 0 to 1 which determines how much spatial information is incorporated. 
Larger values of `lambda` incorporate more spatial information for identifying
clusters.

```{r, eval = T}
joint <- getBanksyMatrix(bank, lambda = 0.25)

joint$expr[1:5,1:5]
joint$locs[1:5,]
```

Run PCA on the Banksy matrix for `lambda = 0` (no spatial information) 
and `lambda = 0.25`. This populates the `reduction` slot:

```{r, eval = T}
bank <- RunPCA(bank, lambda = c(0, 0.25), npcs = 30)
names(bank@reduction)
```

Visualize PCA and its scree plot:

```{r, eval = T, fig.height=8, fig.width=16}
p1 <- plotReduction(bank, reduction = 'pca_0.25')
p2 <- plotScree(bank, lambda = 0.25)
gridExtra::grid.arrange(p1, p2, ncol = 2)
```

For visualization, we run UMAP on 30 principal components:

```{r, eval = T}
bank <- RunUMAP(bank, lambda = 0.25, npcs = 30)
```

Next, we obtain cluster assignments using graph-based clustering with the Leiden
algorithm. Specify the following parameters:

* `resolution`. Leiden clustering resolution.  
* `k.neighbours`. Number of k neighbours to use for constructing sNN.

```{r, eval = T}
set.seed(1234)
bank <- ClusterBanksy(bank, lambda = c(0, 0.25), method = 'leiden',
                      k.neighbors = 40, resolution = 1)
```

## Visualization

We can visualize the UMAP and spatial plots by the clustering run:

```{r, eval = T}
run1 <- 'clust_lam0_k40_res1'
run2 <- 'clust_lam0.25_k40_res1'

plotReduction(bank, reduction = 'umap_0.25', by = run2, type = 'discrete', pt.size = 0.02)
```

Observe the effects of incorporating spatially information (right, `lambda = 0.25`) 
in identifying clusters: 

```{r, eval = T, fig.height=8, fig.width=18}
features <- c(run1, run2)
feature.types <- rep('discrete', 2)
main <- c('Lambda=0', 'Lambda=0.25')
plotSpatialFeatures(bank, by = features, type = feature.types, main = main, 
                    pt.size = 1.5, main.size = 15, nrow = 1, ncol = 2)
```

Heatmap of the cells, annotated by the clustering run with barplots of the 
number of detected genes and total count:

```{r, fig.width=15, fig.height=10, eval = T}
plotHeatmap(bank, assay = 'banksy',
            lambda = 0.25,
            annotate = TRUE,
            annotate.by = run2,
            barplot.by = c('num_genes', 'total_count'))
```

# Session information
```{r, eval = T}
sessionInfo()
```
