---
title: "Finding optimal clustering parameters"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Finding optimal clustering parameters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

We currently implement four algorithms for clustering the BANKSY matrix with  *ClusterBanksy*: Leiden (default), Louvain, k-means, and model based clustering.
Here, we demonstrate how to perform a grid search of parameters for 
Leiden clustering. See `?ClusterBanksy` for more details on the parameters for
different clustering methods.

## Parameters

The `lambda` parameter is a mixing parameter $\in[0,1]$ which determines how 
much spatial information is incorporated for clustering. Larger values 
incorporate more spatial information. Let the gene-cell matrix be $G_O$ and the 
neighbour feature-cell matrix be $G_N$. The joint matrix used for clustering is 
the (row) concatenation of $\sqrt{1-\lambda}\;G_O$ and $\sqrt{\lambda}\;G_N$.

`k.neighbours` is the number of k nearest neighbors used to construct the 
shared nearest neighbors network. `resolution` is the resolution used in Leiden clustering. Higher resolutions yield more clusters.

We first set up the data for clustering:

```{r setup, eval=T, message=F, warning=F}
library(Banksy)
library(ggplot2)
library(gridExtra)

data("hippocampus")
expr <- hippocampus$expression
locs <- hippocampus$locations
bank <- BanksyObject(own.expr = expr, cell.locs = locs)
bank <- NormalizeBanksy(bank)
bank <- ComputeBanksy(bank)
bank <- ScaleBanksy(bank)
bank <- RunPCA(bank, lambda = c(0, 0.3), npcs = 20)
```

## Grid search

Define a parameter space. We explore different combinations of `lambda` and 
`resolution`, fixing `kneighbours`:

```{r params, eval=T}
lam <- c(0, 0.3)
res <- c(0.8, 1.2)
knbr <- 50

set.seed(42)
bank <- ClusterBanksy(bank, lambda = lam, resolution = res, k.neighbors = knbr, npcs = 20)
```

This populates the `meta.data` slot of the *BanksyObject* with cluster labels
for each combination of parameters:

```{r mdata, eval=T}
head(meta.data(bank))
```

## Cluster similarity

To compare clustering labels from different parameter combinations, the package
implements the *getARI* and *plotARI* functions. These compute the adjusted 
Rand index (ARI) for all pairs of clusters to assess the similarity of 
clustering labels. 

```{r runari, eval=T, fig.height=4.5, fig.width=5, fig.align='center'}
getARI(bank)

plotARI(bank) 
```

## Connecting clusters

To visually compare between clusters obtained with different combination of 
parameters (a parameter run), the package implements *ConnectClusters* which
performs a mapping to harmonise cluster labels between different parameter runs.

```{r connect, eval=T}
bank <- ConnectClusters(bank, map.to = 'clust_lam0.3_k50_res1.2')

head(meta.data(bank))
```

This updates the `meta.data` slot with new cluster labels that can be used for visualisation. We can visualise connected output as follows.

First, obtain cluster names:

```{r clustnames, eval=T}
mdnames <- names(meta.data(bank))
clustnames <- mdnames[grep('^clust', mdnames)]
```

Then, visualise the cluster runs:

```{r out, eval=T, fig.width=10, fig.height=8}
plotSpatialFeatures(bank, by = clustnames, type = rep('discrete', 4), 
                    nrow = 2, ncol = 2, main = clustnames, main.size = 10)
```

We visualise the differences between clustering with `lam=0` and `lam=0.3` more finely by splitting the clusters with `ggplot2::facet_wrap`:

```{r wrap, eval=T, fig.width=12, fig.height=6, fig.align='center'}
p1 <- plotSpatial(bank, by = clustnames[2], type = 'discrete', 
            main = clustnames[2], main.size = 10, pt.size = 0.1) + facet_wrap(~ feature)

p2 <- plotSpatial(bank, by = clustnames[4], type = 'discrete', 
            main = clustnames[4], main.size = 10, pt.size = 0.1) + facet_wrap(~ feature)

grid.arrange(p1, p2, ncol = 2)
```
