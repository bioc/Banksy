---
title: "Integrating Banksy with other packages"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Integrating Banksy with other packages}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This article describes integration of *Banksy* with two other packages used for
single-cell and spatial transcriptomic analyses, *Giotto* and *Seurat*. 
We first compute the *Banksy* matrix, which will be used as inputs to the 
*Giotto* and *Seurat* workflows.

```{r setup, eval=F}
library(Banksy)
expr <- readRDS(system.file('/extdata/expression.rds', package = 'Banksy'))
locs <- readRDS(system.file('/extdata/locations.rds', package = 'Banksy'))
bank <- BanksyObject(own.expr = expr,
                     cell.locs = locs)
bank <- NormalizeBanksy(bank)
bank <- ComputeBanksy(bank)
bank <- ScaleBanksy(bank)
combined <- getBanksyMatrix(bank)
```

## Integration with Giotto

We first create the *Giotto* object. Supply the *Banksy* matrix to the `raw_exprs` and `norm_expr` slot in *createGiottoObject*, along with cell locations to the `spatial_locs` slot. Here, we also create instructions giving the python path and docker usage. More information can be found at the *Giotto* documentation page [here](https://rubd.github.io/Giotto_site/reference/index.html).

```{r giotto, eval=F}
library(Giotto)

instr <- createGiottoInstructions(python_path = '/usr/bin/python3',
                                  is_docker = TRUE)

giotto <- createGiottoObject(raw_exprs = combined$expr,
                             norm_expr = combined$expr,
                             spatial_locs = combined$locs,
                             instructions = instr)
```

Next, run principal component analysis:

```{r giotto-pca, eval=F}
giotto <- runPCA(giotto, expression_values = 'normalized', ncp = 50)
plotPCA(giotto)
screePlot(giotto)
``` 

Run non-linear dimensionality reduction, create a shared nearest neighbour 
network and run leiden clustering.

```{r giotto-cluster, eval=F}
giotto <- runUMAP(giotto, dimensions_to_use = 1:15)
giotto <- createNearestNetwork(giotto, type = 'sNN', k = 40, dimensions_to_use = 1:15)
giotto <- doLeidenCluster(giotto, resolution = 0.8, name = 'leiden_clus')

spatDimPlot2D(giotto, cell_color = 'leiden_clus', 
              dim_point_size = 1, dim_point_border_col = 'transparent',
              spat_point_size = 1, spat_point_border_col = 'transparent')
``` 

Run BinSpect to identify genes with spatially coherent expression patterns:

```{r giotto-spatial-ge, eval=F}
giotto <- createSpatialDelaunayNetwork(giotto, minimum_k = 2)
spatialgenes <- binSpect(giotto, bin_method = 'kmeans')
spatialgenes <-  spatialgenes[!grepl('nbr', genes),,] 
spatGenePlot(giotto, expression_values = 'scaled', 
             genes = spatialgenes[1]$genes, point_size = 2,
             point_shape = 'border', point_border_stroke = 0.1, cow_n_col = 1)
``` 

## Integration with Seurat

We first create the *Seurat* object by supplying the *Banksy* matrix to *CreateSeuratObject*. Since the data has been scaled, we populate the
`scale.data` slot with the *Banksy* matrix.

```{r seurat, eval=F}
seu <- CreateSeuratObject(counts = combined$expr)
seu <- SetAssayData(seu, slot = "scale.data", new.data = combined$expr)
```

Run principal component analysis:

```{r seurat-process, eval=F}
seu <- FindVariableFeatures(seu)
seu <- RunPCA(seu)
ElbowPlot(seu)
```

Run non-linear dimensionality reduction, create a shared nearest neighbour 
network and run leiden clustering.

```{r seurat-cluster, eval=F}
seu <- RunUMAP(seu, dims = 1:10)
seu <- FindNeighbors(seu)
seu <- FindClusters(seu, resolution = 0.5, algorithm = 4)

meta.data(bank)[['seurat_clusters']] <- as.numeric(seu@meta.data$seurat_clusters)
plotSpatialDims(bank, by = 'seurat_clusters')
```

Find cluster-specific markers:

```{r seurat-marker, eval=F}
markers <- data.table(FindAllMarkers(seu, only.pos = TRUE))
top <- markers[order(avg_logFC, decreasing = T), head(.SD, 3), by=cluster]
top <-  top[!grepl('nbr', gene),,] 

DotPlot(seu, features = unique(top$gene), cluster.idents = T) + 
    theme(axis.text.x = element_text(angle = 45, vjust = 0.4))
``` 

